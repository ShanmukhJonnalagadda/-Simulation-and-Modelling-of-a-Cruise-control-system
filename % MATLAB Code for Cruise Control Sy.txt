% MATLAB Code for Cruise Control System with PI Controller
% Implementation without using Control System Toolbox or specialized functions

%% Main Simulation Script
clear all;
clc;

% Define simulation parameters
sim_time = 100;          % Simulation time (seconds)
dt = 0.01;               % Time step (seconds)
t = 0:dt:sim_time;       % Time vector
N = length(t);           % Number of time steps

% Define vehicle parameters
m = 1000;                % Vehicle mass (kg)
b = 50;                  % Damping coefficient (NÂ·s/m)

% Define reference input (desired speed)
desired_speed = zeros(size(t));
% Step input at t=10s
desired_speed(t>=10) = 20;  % Desired speed: 20 m/s (72 km/h)

% P(s) Controller parameters
% This could be a P, PI, or PID controller
% For this implementation, we'll use a PI controller
Kp = 500;    % Proportional gain
Ki = 50;     % Integral gain

% Initialize arrays for storing results
position = zeros(size(t));
speed = zeros(size(t));
force = zeros(size(t));
error_signal = zeros(size(t));
integral_error = 0;
out_speed = zeros(size(t));
out_ref_speed = desired_speed;  % Direct output of reference speed

% Initial conditions
position(1) = 0;
speed(1) = 0;

% Simulation loop
for i = 1:N-1
    % Calculate error (desired speed - actual speed)
    error_signal(i) = desired_speed(i) - speed(i);
    
    % P(s) controller implementation
    % Update integral error
    integral_error = integral_error + error_signal(i) * dt;
    
    % Calculate control input based on P(s) controller design
    p_term = Kp * error_signal(i);
    i_term = Ki * integral_error;
    
    force(i) = p_term + i_term;
    
    % Vehicle dynamics equations:
    % dx/dt = v
    % dv/dt = (F - b*v)/m
    % Using Euler integration method
    
    % Calculate acceleration
    acceleration = (force(i) - b * speed(i)) / m;
    
    % Update speed: v(t+dt) = v(t) + a*dt
    speed(i+1) = speed(i) + acceleration * dt;
    
    % Update position: x(t+dt) = x(t) + v*dt
    position(i+1) = position(i) + speed(i) * dt;
    
    % Output signals
    out_speed(i) = speed(i);
end

% Set final output values
out_speed(N) = speed(N);
error_signal(N) = desired_speed(N) - speed(N);

% Plot results
figure(1);
subplot(4,1,1);
plot(t, desired_speed, 'r--', t, speed, 'b-', 'LineWidth', 1.5);
grid on;
legend('Desired Speed', 'Actual Speed');
title('Cruise Control System - P(s) Controller');
ylabel('Speed (m/s)');

subplot(4,1,2);
plot(t, position, 'g-', 'LineWidth', 1.5);
grid on;
title('Vehicle Position');
ylabel('Position (m)');

subplot(4,1,3);
plot(t, force, 'k-', 'LineWidth', 1.5);
grid on;
title('Control Force');
ylabel('Force (N)');

subplot(4,1,4);
plot(t, error_signal, 'r-', 'LineWidth', 1.5);
grid on;
title('Speed Error');
ylabel('Error (m/s)');
xlabel('Time (s)');

% Calculate and display performance metrics
fprintf('Performance Metrics:\n');
fprintf('Rise Time: %.2f seconds\n', calculate_rise_time(t, speed, 0.1, 0.9, 20));
fprintf('Settling Time: %.2f seconds\n', calculate_settling_time(t, speed, 0.02, 20));
fprintf('Overshoot: %.2f%%\n', calculate_overshoot(speed, 20));
fprintf('Steady-State Error: %.4f m/s\n', abs(speed(end) - 20));

% Function to create a simple visualization of the block diagram
function create_block_diagram()
    figure(2);
    clf;
    axis([0 10 0 6]);
    axis off;
    
    % Draw blocks
    rectangle('Position', [1, 3, 1, 1], 'EdgeColor', 'k');
    text(1.5, 3.5, 'Desired Speed', 'HorizontalAlignment', 'center');
    
    rectangle('Position', [3, 3, 1, 1], 'EdgeColor', 'k');
    text(3.5, 3.5, 'P(s)', 'HorizontalAlignment', 'center');
    
    rectangle('Position', [5, 3, 1.5, 1], 'EdgeColor', 'k');
    text(5.75, 3.5, 'Vehicle Dynamics', 'HorizontalAlignment', 'center');
    
    rectangle('Position', [8, 3, 1, 1], 'EdgeColor', 'k');
    text(8.5, 3.5, 'out.Speed', 'HorizontalAlignment', 'center');
    
    rectangle('Position', [8, 1, 1, 1], 'EdgeColor', 'k');
    text(8.5, 1.5, 'out.ref_speed', 'HorizontalAlignment', 'center');
    
    % Draw connections
    % Horizontal lines
    line([2, 3], [3.5, 3.5], 'Color', 'k');
    line([4, 5], [3.5, 3.5], 'Color', 'k');
    line([6.5, 8], [3.5, 3.5], 'Color', 'k');
    
    % Feedback line
    line([6.5, 7], [3.3, 3.3], 'Color', 'k');
    line([7, 7], [3.3, 2.5], 'Color', 'k');
    line([7, 2.5], [2.5, 2.5], 'Color', 'k');
    line([2.5, 2.5], [2.5, 3.5], 'Color', 'k');
    
    % Reference output line
    line([2, 2], [3.5, 1.5], 'Color', 'k');
    line([2, 8], [1.5, 1.5], 'Color', 'k');
    
    % Summing junction
    circle = viscircles([2.5, 3.5], 0.2, 'EdgeColor', 'k', 'LineWidth', 1);
    
    title('Cruise Control System Block Diagram');
end

% Performance metrics calculation functions
function rise_time = calculate_rise_time(t, response, low_threshold, high_threshold, final_value)
    % Calculate the time it takes for the response to rise from low_threshold to high_threshold of final value
    low_idx = find(response >= low_threshold*final_value, 1);
    high_idx = find(response >= high_threshold*final_value, 1);
    
    if isempty(low_idx) || isempty(high_idx)
        rise_time = NaN;
    else
        rise_time = t(high_idx) - t(low_idx);
    end
end

function settling_time = calculate_settling_time(t, response, tolerance, final_value)
    % Calculate the time it takes for the response to stay within tolerance of final value
    steady_state = final_value;
    tolerance_band = tolerance * steady_state;
    
    % Find when response enters and stays within tolerance band
    in_band = abs(response - steady_state) <= tolerance_band;
    
    % Check from the end backwards to find when it first entered the band and stayed there
    idx = find(diff([0; in_band]) == 1, 1, 'last');
    
    if isempty(idx)
        settling_time = NaN;
    else
        settling_time = t(idx);
    end
end

function max_overshoot = calculate_overshoot(response, final_value)
    % Calculate the maximum overshoot as a percentage of final value
    max_value = max(response);
    
    if max_value > final_value
        max_overshoot = 100 * (max_value - final_value) / final_value;
    else
        max_overshoot = 0;
    end
end

% Uncomment to display block diagram
% create_block_diagram();